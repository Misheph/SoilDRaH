---
title: "readTemplate Function"
author: "Ursa Pillay"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{readTemplate Function}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Setup

First, load the libraries that contain the functions needed. Then set the data directory to the folder where the data tables should be downloaded.

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
library(readr)
library(tibble)
library(plyr)
library(dplyr)
library(tidyr)
dataDir <- '~/Desktop/SoilDRaH/data/test'
knitr::opts_chunk$set(eval=TRUE, echo=FALSE)
```

## Download Data

The downloadUrl dataframe holds the url to download each data table and the name of each destination file.

```{r, echo=TRUE}

#create test download data
downloadUrl.df <- tibble::tribble(~url, ~base_filename, 
                                    "url1", "test_data_table1.csv", 
                                    "url2", "test_data_table2.csv")

```

```{r}

knitr::kable(downloadUrl.df)

```

Each data table is downloaded from its url into a file in the specified data directory with its respective file name.

```{r, echo=TRUE}

#loop through each url
for(rowIndex in 1:nrow(downloadUrl.df)){
    
    #if file does not exist yet, download file from url into destination file
    if(!file.exists(file.path(dataDir, 
                              downloadUrl.df$base_filename[rowIndex]))){
      utils::download.file(url = downloadUrl.df$url[rowIndex], 
                    destfile = file.path(dataDir, 
                                         downloadUrl.df$base_filename[rowIndex]))
    }
  }

```


## Read in Data

Read in each downloaded data table (assuming they are csv files) as dataframes. For each dataframe, set all columns to character data type, and set its name to the filename without the csv extension. Store the list of dataframes as an element in the 'ans' list.

```{r, echo=TRUE}

#create list to store return data
ans.ls <- list()

#read each csv in as dataframe
ans.ls$original_data <- lapply(file.path(dataDir, downloadUrl.df$base_filename), FUN = read_csv, 
                               
                               #set all columns to character data type
                               col_type = readr::cols(.default = readr::col_character()))

#set names of dataframes to filename without csv extension
names(ans.ls$original_data) = sub(".csv", "", downloadUrl.df$base_filename)

```

```{r}

knitr::kable(ans.ls$original_data)

```

## Read in Annotations

Read in annotation table and store as dataframe in ans list.

```{r, echo=TRUE}

#read in test annotations
ans.ls$annotations <- readr::read_csv(file.path(dataDir, "test_annotations.csv"),
                                      
                                      #set columns to character data type
                                      col_type = readr::cols(.default = readr::col_character()))

```

```{r}

knitr::kable(ans.ls$annotations)

```

## Pivot Data Longer

This ldply function reformats each dataframe in the list of original data. To each dataframe, give the rows a unique index to identify each observation. Then pivot the data longer so that each observation has its own rows for each variable defined in the original table. The ldply function binds the dataframes together (stacks them), then adds a column for the table id set to the name of each original dataframe. Store this long format table as an element in ans list.

```{r echo=TRUE}

#apply function to each dataframe
ans.ls$longtable <- plyr::ldply(.data = ans.ls$original_data, .fun = function(x) {
    
    #check if row_number column already exists
    if("row_number" %in% colnames(x)) {
      warning("Replacing row_number with row order and using as a unique identifier.")
    }
    
    #create temp variable to store altered dataframe
    temp <- x %>%
      
      #give each row a number as unique identifier
      dplyr::mutate(row_number = 1:n()) %>%
      
      #pivot table longer
      tidyr::pivot_longer(cols = -c(row_number), names_to = 'column_id',
                   values_to = 'with_entry', values_drop_na = TRUE)
    
    #return pivoted dataframe
    return(temp)
    
  #set table_id column to names of dataframes  
  }, .id = "table_id")

```

```{r}

knitr::kable(ans.ls$longtable)

```

## Join Data with Annotations

Join the table with the annotations, matching the rows by table id and column id. Insert the values for each observation in the entry column.

```{r, echo=TRUE}

ans.ls$longtable <- ans.ls$longtable %>%
    
    #join long table with annotations by table and column ids
    dplyr::full_join(ans.ls$annotations, 
              by = join_by(table_id, column_id),
              suffix = c('.data', ''),
              relationship = "many-to-many") %>%
    
    #replace value placeholders in with_entry column with values from data
    dplyr::mutate(
      with_entry = dplyr::if_else((with_entry == "--") | is.na(with_entry),
                                  with_entry.data, with_entry)) %>%
    dplyr::select(-with_entry.data)

```

```{r}

knitr::kable(ans.ls$longtable)

```

## Return Data

Return a nested list containing the list of the original data tables, the annotations, and the reformatted data.

```{r, echo=TRUE, results='hide'}

return(ans.ls)

```

```{r}

knitr::kable(ans.ls$original_data)
knitr::kable(ans.ls$annotations)
knitr::kable(ans.ls$longtable)

```
